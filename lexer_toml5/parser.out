Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    NEWLINE

Grammar

Rule 0     S' -> toml
Rule 1     toml -> expression_list
Rule 2     expression_list -> expression
Rule 3     expression_list -> expression expression_list
Rule 4     expression -> key_val
Rule 5     expression -> table
Rule 6     key_val -> key EQUALS value
Rule 7     key -> simple_key
Rule 8     key -> dotted_key
Rule 9     simple_key -> bare_key
Rule 10    simple_key -> quoted_key
Rule 11    bare_key -> IDENTIFIER
Rule 12    bare_key -> INTEGER
Rule 13    quoted_key -> STRING
Rule 14    quoted_key -> LITERAL_STRING
Rule 15    dotted_key -> simple_key DOT simple_key
Rule 16    dotted_key -> FLOAT
Rule 17    value -> STRING
Rule 18    value -> LITERAL_STRING
Rule 19    value -> INTEGER
Rule 20    value -> FLOAT
Rule 21    value -> HEX_INTEGER
Rule 22    value -> OCT_INTEGER
Rule 23    value -> BIN_INTEGER
Rule 24    value -> BOOLEAN
Rule 25    value -> OFFSET_DATE_TIME
Rule 26    value -> LOCAL_DATE_TIME
Rule 27    value -> LOCAL_DATE
Rule 28    value -> LOCAL_TIME
Rule 29    value -> MULTILINE_STRING
Rule 30    value -> LITERAL_MULTILINE_STRING
Rule 31    value -> array
Rule 32    value -> inline_table
Rule 33    array -> LBRACKET value_list RBRACKET
Rule 34    value_list -> value
Rule 35    value_list -> value COMMA value_list
Rule 36    inline_table -> LBRACE key_val_list RBRACE
Rule 37    key_val_list -> key_val
Rule 38    key_val_list -> key_val COMMA key_val_list
Rule 39    table -> LBRACKET key RBRACKET

Terminals, with rules where they appear

BIN_INTEGER          : 23
BOOLEAN              : 24
COMMA                : 35 38
COMMENT              : 
DOT                  : 15
EQUALS               : 6
FLOAT                : 16 20
HEX_INTEGER          : 21
IDENTIFIER           : 11
INTEGER              : 12 19
LBRACE               : 36
LBRACKET             : 33 39
LITERAL_MULTILINE_STRING : 30
LITERAL_STRING       : 14 18
LOCAL_DATE           : 27
LOCAL_DATE_TIME      : 26
LOCAL_TIME           : 28
MULTILINE_STRING     : 29
NEWLINE              : 
OCT_INTEGER          : 22
OFFSET_DATE_TIME     : 25
RBRACE               : 36
RBRACKET             : 33 39
STRING               : 13 17
error                : 

Nonterminals, with rules where they appear

array                : 31
bare_key             : 9
dotted_key           : 8
expression           : 2 3
expression_list      : 1 3
inline_table         : 32
key                  : 6 39
key_val              : 4 37 38
key_val_list         : 36 38
quoted_key           : 10
simple_key           : 7 15 15
table                : 5
toml                 : 0
value                : 6 34 35
value_list           : 33 35

Parsing method: LALR

state 0

    (0) S' -> . toml
    (1) toml -> . expression_list
    (2) expression_list -> . expression
    (3) expression_list -> . expression expression_list
    (4) expression -> . key_val
    (5) expression -> . table
    (6) key_val -> . key EQUALS value
    (39) table -> . LBRACKET key RBRACKET
    (7) key -> . simple_key
    (8) key -> . dotted_key
    (9) simple_key -> . bare_key
    (10) simple_key -> . quoted_key
    (15) dotted_key -> . simple_key DOT simple_key
    (16) dotted_key -> . FLOAT
    (11) bare_key -> . IDENTIFIER
    (12) bare_key -> . INTEGER
    (13) quoted_key -> . STRING
    (14) quoted_key -> . LITERAL_STRING

    LBRACKET        shift and go to state 7
    FLOAT           shift and go to state 12
    IDENTIFIER      shift and go to state 13
    INTEGER         shift and go to state 14
    STRING          shift and go to state 15
    LITERAL_STRING  shift and go to state 16

    toml                           shift and go to state 1
    expression_list                shift and go to state 2
    expression                     shift and go to state 3
    key_val                        shift and go to state 4
    table                          shift and go to state 5
    key                            shift and go to state 6
    simple_key                     shift and go to state 8
    dotted_key                     shift and go to state 9
    bare_key                       shift and go to state 10
    quoted_key                     shift and go to state 11

state 1

    (0) S' -> toml .



state 2

    (1) toml -> expression_list .

    $end            reduce using rule 1 (toml -> expression_list .)


state 3

    (2) expression_list -> expression .
    (3) expression_list -> expression . expression_list
    (2) expression_list -> . expression
    (3) expression_list -> . expression expression_list
    (4) expression -> . key_val
    (5) expression -> . table
    (6) key_val -> . key EQUALS value
    (39) table -> . LBRACKET key RBRACKET
    (7) key -> . simple_key
    (8) key -> . dotted_key
    (9) simple_key -> . bare_key
    (10) simple_key -> . quoted_key
    (15) dotted_key -> . simple_key DOT simple_key
    (16) dotted_key -> . FLOAT
    (11) bare_key -> . IDENTIFIER
    (12) bare_key -> . INTEGER
    (13) quoted_key -> . STRING
    (14) quoted_key -> . LITERAL_STRING

    $end            reduce using rule 2 (expression_list -> expression .)
    LBRACKET        shift and go to state 7
    FLOAT           shift and go to state 12
    IDENTIFIER      shift and go to state 13
    INTEGER         shift and go to state 14
    STRING          shift and go to state 15
    LITERAL_STRING  shift and go to state 16

    expression                     shift and go to state 3
    expression_list                shift and go to state 17
    key_val                        shift and go to state 4
    table                          shift and go to state 5
    key                            shift and go to state 6
    simple_key                     shift and go to state 8
    dotted_key                     shift and go to state 9
    bare_key                       shift and go to state 10
    quoted_key                     shift and go to state 11

state 4

    (4) expression -> key_val .

    LBRACKET        reduce using rule 4 (expression -> key_val .)
    FLOAT           reduce using rule 4 (expression -> key_val .)
    IDENTIFIER      reduce using rule 4 (expression -> key_val .)
    INTEGER         reduce using rule 4 (expression -> key_val .)
    STRING          reduce using rule 4 (expression -> key_val .)
    LITERAL_STRING  reduce using rule 4 (expression -> key_val .)
    $end            reduce using rule 4 (expression -> key_val .)


state 5

    (5) expression -> table .

    LBRACKET        reduce using rule 5 (expression -> table .)
    FLOAT           reduce using rule 5 (expression -> table .)
    IDENTIFIER      reduce using rule 5 (expression -> table .)
    INTEGER         reduce using rule 5 (expression -> table .)
    STRING          reduce using rule 5 (expression -> table .)
    LITERAL_STRING  reduce using rule 5 (expression -> table .)
    $end            reduce using rule 5 (expression -> table .)


state 6

    (6) key_val -> key . EQUALS value

    EQUALS          shift and go to state 18


state 7

    (39) table -> LBRACKET . key RBRACKET
    (7) key -> . simple_key
    (8) key -> . dotted_key
    (9) simple_key -> . bare_key
    (10) simple_key -> . quoted_key
    (15) dotted_key -> . simple_key DOT simple_key
    (16) dotted_key -> . FLOAT
    (11) bare_key -> . IDENTIFIER
    (12) bare_key -> . INTEGER
    (13) quoted_key -> . STRING
    (14) quoted_key -> . LITERAL_STRING

    FLOAT           shift and go to state 12
    IDENTIFIER      shift and go to state 13
    INTEGER         shift and go to state 14
    STRING          shift and go to state 15
    LITERAL_STRING  shift and go to state 16

    key                            shift and go to state 19
    simple_key                     shift and go to state 8
    dotted_key                     shift and go to state 9
    bare_key                       shift and go to state 10
    quoted_key                     shift and go to state 11

state 8

    (7) key -> simple_key .
    (15) dotted_key -> simple_key . DOT simple_key

    EQUALS          reduce using rule 7 (key -> simple_key .)
    RBRACKET        reduce using rule 7 (key -> simple_key .)
    DOT             shift and go to state 20


state 9

    (8) key -> dotted_key .

    EQUALS          reduce using rule 8 (key -> dotted_key .)
    RBRACKET        reduce using rule 8 (key -> dotted_key .)


state 10

    (9) simple_key -> bare_key .

    DOT             reduce using rule 9 (simple_key -> bare_key .)
    EQUALS          reduce using rule 9 (simple_key -> bare_key .)
    RBRACKET        reduce using rule 9 (simple_key -> bare_key .)


state 11

    (10) simple_key -> quoted_key .

    DOT             reduce using rule 10 (simple_key -> quoted_key .)
    EQUALS          reduce using rule 10 (simple_key -> quoted_key .)
    RBRACKET        reduce using rule 10 (simple_key -> quoted_key .)


state 12

    (16) dotted_key -> FLOAT .

    EQUALS          reduce using rule 16 (dotted_key -> FLOAT .)
    RBRACKET        reduce using rule 16 (dotted_key -> FLOAT .)


state 13

    (11) bare_key -> IDENTIFIER .

    DOT             reduce using rule 11 (bare_key -> IDENTIFIER .)
    EQUALS          reduce using rule 11 (bare_key -> IDENTIFIER .)
    RBRACKET        reduce using rule 11 (bare_key -> IDENTIFIER .)


state 14

    (12) bare_key -> INTEGER .

    DOT             reduce using rule 12 (bare_key -> INTEGER .)
    EQUALS          reduce using rule 12 (bare_key -> INTEGER .)
    RBRACKET        reduce using rule 12 (bare_key -> INTEGER .)


state 15

    (13) quoted_key -> STRING .

    DOT             reduce using rule 13 (quoted_key -> STRING .)
    EQUALS          reduce using rule 13 (quoted_key -> STRING .)
    RBRACKET        reduce using rule 13 (quoted_key -> STRING .)


state 16

    (14) quoted_key -> LITERAL_STRING .

    DOT             reduce using rule 14 (quoted_key -> LITERAL_STRING .)
    EQUALS          reduce using rule 14 (quoted_key -> LITERAL_STRING .)
    RBRACKET        reduce using rule 14 (quoted_key -> LITERAL_STRING .)


state 17

    (3) expression_list -> expression expression_list .

    $end            reduce using rule 3 (expression_list -> expression expression_list .)


state 18

    (6) key_val -> key EQUALS . value
    (17) value -> . STRING
    (18) value -> . LITERAL_STRING
    (19) value -> . INTEGER
    (20) value -> . FLOAT
    (21) value -> . HEX_INTEGER
    (22) value -> . OCT_INTEGER
    (23) value -> . BIN_INTEGER
    (24) value -> . BOOLEAN
    (25) value -> . OFFSET_DATE_TIME
    (26) value -> . LOCAL_DATE_TIME
    (27) value -> . LOCAL_DATE
    (28) value -> . LOCAL_TIME
    (29) value -> . MULTILINE_STRING
    (30) value -> . LITERAL_MULTILINE_STRING
    (31) value -> . array
    (32) value -> . inline_table
    (33) array -> . LBRACKET value_list RBRACKET
    (36) inline_table -> . LBRACE key_val_list RBRACE

    STRING          shift and go to state 22
    LITERAL_STRING  shift and go to state 23
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    HEX_INTEGER     shift and go to state 26
    OCT_INTEGER     shift and go to state 27
    BIN_INTEGER     shift and go to state 28
    BOOLEAN         shift and go to state 29
    OFFSET_DATE_TIME shift and go to state 30
    LOCAL_DATE_TIME shift and go to state 31
    LOCAL_DATE      shift and go to state 32
    LOCAL_TIME      shift and go to state 33
    MULTILINE_STRING shift and go to state 34
    LITERAL_MULTILINE_STRING shift and go to state 35
    LBRACKET        shift and go to state 38
    LBRACE          shift and go to state 39

    value                          shift and go to state 21
    array                          shift and go to state 36
    inline_table                   shift and go to state 37

state 19

    (39) table -> LBRACKET key . RBRACKET

    RBRACKET        shift and go to state 40


state 20

    (15) dotted_key -> simple_key DOT . simple_key
    (9) simple_key -> . bare_key
    (10) simple_key -> . quoted_key
    (11) bare_key -> . IDENTIFIER
    (12) bare_key -> . INTEGER
    (13) quoted_key -> . STRING
    (14) quoted_key -> . LITERAL_STRING

    IDENTIFIER      shift and go to state 13
    INTEGER         shift and go to state 14
    STRING          shift and go to state 15
    LITERAL_STRING  shift and go to state 16

    simple_key                     shift and go to state 41
    bare_key                       shift and go to state 10
    quoted_key                     shift and go to state 11

state 21

    (6) key_val -> key EQUALS value .

    LBRACKET        reduce using rule 6 (key_val -> key EQUALS value .)
    FLOAT           reduce using rule 6 (key_val -> key EQUALS value .)
    IDENTIFIER      reduce using rule 6 (key_val -> key EQUALS value .)
    INTEGER         reduce using rule 6 (key_val -> key EQUALS value .)
    STRING          reduce using rule 6 (key_val -> key EQUALS value .)
    LITERAL_STRING  reduce using rule 6 (key_val -> key EQUALS value .)
    $end            reduce using rule 6 (key_val -> key EQUALS value .)
    COMMA           reduce using rule 6 (key_val -> key EQUALS value .)
    RBRACE          reduce using rule 6 (key_val -> key EQUALS value .)


state 22

    (17) value -> STRING .

    LBRACKET        reduce using rule 17 (value -> STRING .)
    FLOAT           reduce using rule 17 (value -> STRING .)
    IDENTIFIER      reduce using rule 17 (value -> STRING .)
    INTEGER         reduce using rule 17 (value -> STRING .)
    STRING          reduce using rule 17 (value -> STRING .)
    LITERAL_STRING  reduce using rule 17 (value -> STRING .)
    $end            reduce using rule 17 (value -> STRING .)
    COMMA           reduce using rule 17 (value -> STRING .)
    RBRACE          reduce using rule 17 (value -> STRING .)
    RBRACKET        reduce using rule 17 (value -> STRING .)


state 23

    (18) value -> LITERAL_STRING .

    LBRACKET        reduce using rule 18 (value -> LITERAL_STRING .)
    FLOAT           reduce using rule 18 (value -> LITERAL_STRING .)
    IDENTIFIER      reduce using rule 18 (value -> LITERAL_STRING .)
    INTEGER         reduce using rule 18 (value -> LITERAL_STRING .)
    STRING          reduce using rule 18 (value -> LITERAL_STRING .)
    LITERAL_STRING  reduce using rule 18 (value -> LITERAL_STRING .)
    $end            reduce using rule 18 (value -> LITERAL_STRING .)
    COMMA           reduce using rule 18 (value -> LITERAL_STRING .)
    RBRACE          reduce using rule 18 (value -> LITERAL_STRING .)
    RBRACKET        reduce using rule 18 (value -> LITERAL_STRING .)


state 24

    (19) value -> INTEGER .

    LBRACKET        reduce using rule 19 (value -> INTEGER .)
    FLOAT           reduce using rule 19 (value -> INTEGER .)
    IDENTIFIER      reduce using rule 19 (value -> INTEGER .)
    INTEGER         reduce using rule 19 (value -> INTEGER .)
    STRING          reduce using rule 19 (value -> INTEGER .)
    LITERAL_STRING  reduce using rule 19 (value -> INTEGER .)
    $end            reduce using rule 19 (value -> INTEGER .)
    COMMA           reduce using rule 19 (value -> INTEGER .)
    RBRACE          reduce using rule 19 (value -> INTEGER .)
    RBRACKET        reduce using rule 19 (value -> INTEGER .)


state 25

    (20) value -> FLOAT .

    LBRACKET        reduce using rule 20 (value -> FLOAT .)
    FLOAT           reduce using rule 20 (value -> FLOAT .)
    IDENTIFIER      reduce using rule 20 (value -> FLOAT .)
    INTEGER         reduce using rule 20 (value -> FLOAT .)
    STRING          reduce using rule 20 (value -> FLOAT .)
    LITERAL_STRING  reduce using rule 20 (value -> FLOAT .)
    $end            reduce using rule 20 (value -> FLOAT .)
    COMMA           reduce using rule 20 (value -> FLOAT .)
    RBRACE          reduce using rule 20 (value -> FLOAT .)
    RBRACKET        reduce using rule 20 (value -> FLOAT .)


state 26

    (21) value -> HEX_INTEGER .

    LBRACKET        reduce using rule 21 (value -> HEX_INTEGER .)
    FLOAT           reduce using rule 21 (value -> HEX_INTEGER .)
    IDENTIFIER      reduce using rule 21 (value -> HEX_INTEGER .)
    INTEGER         reduce using rule 21 (value -> HEX_INTEGER .)
    STRING          reduce using rule 21 (value -> HEX_INTEGER .)
    LITERAL_STRING  reduce using rule 21 (value -> HEX_INTEGER .)
    $end            reduce using rule 21 (value -> HEX_INTEGER .)
    COMMA           reduce using rule 21 (value -> HEX_INTEGER .)
    RBRACE          reduce using rule 21 (value -> HEX_INTEGER .)
    RBRACKET        reduce using rule 21 (value -> HEX_INTEGER .)


state 27

    (22) value -> OCT_INTEGER .

    LBRACKET        reduce using rule 22 (value -> OCT_INTEGER .)
    FLOAT           reduce using rule 22 (value -> OCT_INTEGER .)
    IDENTIFIER      reduce using rule 22 (value -> OCT_INTEGER .)
    INTEGER         reduce using rule 22 (value -> OCT_INTEGER .)
    STRING          reduce using rule 22 (value -> OCT_INTEGER .)
    LITERAL_STRING  reduce using rule 22 (value -> OCT_INTEGER .)
    $end            reduce using rule 22 (value -> OCT_INTEGER .)
    COMMA           reduce using rule 22 (value -> OCT_INTEGER .)
    RBRACE          reduce using rule 22 (value -> OCT_INTEGER .)
    RBRACKET        reduce using rule 22 (value -> OCT_INTEGER .)


state 28

    (23) value -> BIN_INTEGER .

    LBRACKET        reduce using rule 23 (value -> BIN_INTEGER .)
    FLOAT           reduce using rule 23 (value -> BIN_INTEGER .)
    IDENTIFIER      reduce using rule 23 (value -> BIN_INTEGER .)
    INTEGER         reduce using rule 23 (value -> BIN_INTEGER .)
    STRING          reduce using rule 23 (value -> BIN_INTEGER .)
    LITERAL_STRING  reduce using rule 23 (value -> BIN_INTEGER .)
    $end            reduce using rule 23 (value -> BIN_INTEGER .)
    COMMA           reduce using rule 23 (value -> BIN_INTEGER .)
    RBRACE          reduce using rule 23 (value -> BIN_INTEGER .)
    RBRACKET        reduce using rule 23 (value -> BIN_INTEGER .)


state 29

    (24) value -> BOOLEAN .

    LBRACKET        reduce using rule 24 (value -> BOOLEAN .)
    FLOAT           reduce using rule 24 (value -> BOOLEAN .)
    IDENTIFIER      reduce using rule 24 (value -> BOOLEAN .)
    INTEGER         reduce using rule 24 (value -> BOOLEAN .)
    STRING          reduce using rule 24 (value -> BOOLEAN .)
    LITERAL_STRING  reduce using rule 24 (value -> BOOLEAN .)
    $end            reduce using rule 24 (value -> BOOLEAN .)
    COMMA           reduce using rule 24 (value -> BOOLEAN .)
    RBRACE          reduce using rule 24 (value -> BOOLEAN .)
    RBRACKET        reduce using rule 24 (value -> BOOLEAN .)


state 30

    (25) value -> OFFSET_DATE_TIME .

    LBRACKET        reduce using rule 25 (value -> OFFSET_DATE_TIME .)
    FLOAT           reduce using rule 25 (value -> OFFSET_DATE_TIME .)
    IDENTIFIER      reduce using rule 25 (value -> OFFSET_DATE_TIME .)
    INTEGER         reduce using rule 25 (value -> OFFSET_DATE_TIME .)
    STRING          reduce using rule 25 (value -> OFFSET_DATE_TIME .)
    LITERAL_STRING  reduce using rule 25 (value -> OFFSET_DATE_TIME .)
    $end            reduce using rule 25 (value -> OFFSET_DATE_TIME .)
    COMMA           reduce using rule 25 (value -> OFFSET_DATE_TIME .)
    RBRACE          reduce using rule 25 (value -> OFFSET_DATE_TIME .)
    RBRACKET        reduce using rule 25 (value -> OFFSET_DATE_TIME .)


state 31

    (26) value -> LOCAL_DATE_TIME .

    LBRACKET        reduce using rule 26 (value -> LOCAL_DATE_TIME .)
    FLOAT           reduce using rule 26 (value -> LOCAL_DATE_TIME .)
    IDENTIFIER      reduce using rule 26 (value -> LOCAL_DATE_TIME .)
    INTEGER         reduce using rule 26 (value -> LOCAL_DATE_TIME .)
    STRING          reduce using rule 26 (value -> LOCAL_DATE_TIME .)
    LITERAL_STRING  reduce using rule 26 (value -> LOCAL_DATE_TIME .)
    $end            reduce using rule 26 (value -> LOCAL_DATE_TIME .)
    COMMA           reduce using rule 26 (value -> LOCAL_DATE_TIME .)
    RBRACE          reduce using rule 26 (value -> LOCAL_DATE_TIME .)
    RBRACKET        reduce using rule 26 (value -> LOCAL_DATE_TIME .)


state 32

    (27) value -> LOCAL_DATE .

    LBRACKET        reduce using rule 27 (value -> LOCAL_DATE .)
    FLOAT           reduce using rule 27 (value -> LOCAL_DATE .)
    IDENTIFIER      reduce using rule 27 (value -> LOCAL_DATE .)
    INTEGER         reduce using rule 27 (value -> LOCAL_DATE .)
    STRING          reduce using rule 27 (value -> LOCAL_DATE .)
    LITERAL_STRING  reduce using rule 27 (value -> LOCAL_DATE .)
    $end            reduce using rule 27 (value -> LOCAL_DATE .)
    COMMA           reduce using rule 27 (value -> LOCAL_DATE .)
    RBRACE          reduce using rule 27 (value -> LOCAL_DATE .)
    RBRACKET        reduce using rule 27 (value -> LOCAL_DATE .)


state 33

    (28) value -> LOCAL_TIME .

    LBRACKET        reduce using rule 28 (value -> LOCAL_TIME .)
    FLOAT           reduce using rule 28 (value -> LOCAL_TIME .)
    IDENTIFIER      reduce using rule 28 (value -> LOCAL_TIME .)
    INTEGER         reduce using rule 28 (value -> LOCAL_TIME .)
    STRING          reduce using rule 28 (value -> LOCAL_TIME .)
    LITERAL_STRING  reduce using rule 28 (value -> LOCAL_TIME .)
    $end            reduce using rule 28 (value -> LOCAL_TIME .)
    COMMA           reduce using rule 28 (value -> LOCAL_TIME .)
    RBRACE          reduce using rule 28 (value -> LOCAL_TIME .)
    RBRACKET        reduce using rule 28 (value -> LOCAL_TIME .)


state 34

    (29) value -> MULTILINE_STRING .

    LBRACKET        reduce using rule 29 (value -> MULTILINE_STRING .)
    FLOAT           reduce using rule 29 (value -> MULTILINE_STRING .)
    IDENTIFIER      reduce using rule 29 (value -> MULTILINE_STRING .)
    INTEGER         reduce using rule 29 (value -> MULTILINE_STRING .)
    STRING          reduce using rule 29 (value -> MULTILINE_STRING .)
    LITERAL_STRING  reduce using rule 29 (value -> MULTILINE_STRING .)
    $end            reduce using rule 29 (value -> MULTILINE_STRING .)
    COMMA           reduce using rule 29 (value -> MULTILINE_STRING .)
    RBRACE          reduce using rule 29 (value -> MULTILINE_STRING .)
    RBRACKET        reduce using rule 29 (value -> MULTILINE_STRING .)


state 35

    (30) value -> LITERAL_MULTILINE_STRING .

    LBRACKET        reduce using rule 30 (value -> LITERAL_MULTILINE_STRING .)
    FLOAT           reduce using rule 30 (value -> LITERAL_MULTILINE_STRING .)
    IDENTIFIER      reduce using rule 30 (value -> LITERAL_MULTILINE_STRING .)
    INTEGER         reduce using rule 30 (value -> LITERAL_MULTILINE_STRING .)
    STRING          reduce using rule 30 (value -> LITERAL_MULTILINE_STRING .)
    LITERAL_STRING  reduce using rule 30 (value -> LITERAL_MULTILINE_STRING .)
    $end            reduce using rule 30 (value -> LITERAL_MULTILINE_STRING .)
    COMMA           reduce using rule 30 (value -> LITERAL_MULTILINE_STRING .)
    RBRACE          reduce using rule 30 (value -> LITERAL_MULTILINE_STRING .)
    RBRACKET        reduce using rule 30 (value -> LITERAL_MULTILINE_STRING .)


state 36

    (31) value -> array .

    LBRACKET        reduce using rule 31 (value -> array .)
    FLOAT           reduce using rule 31 (value -> array .)
    IDENTIFIER      reduce using rule 31 (value -> array .)
    INTEGER         reduce using rule 31 (value -> array .)
    STRING          reduce using rule 31 (value -> array .)
    LITERAL_STRING  reduce using rule 31 (value -> array .)
    $end            reduce using rule 31 (value -> array .)
    COMMA           reduce using rule 31 (value -> array .)
    RBRACE          reduce using rule 31 (value -> array .)
    RBRACKET        reduce using rule 31 (value -> array .)


state 37

    (32) value -> inline_table .

    LBRACKET        reduce using rule 32 (value -> inline_table .)
    FLOAT           reduce using rule 32 (value -> inline_table .)
    IDENTIFIER      reduce using rule 32 (value -> inline_table .)
    INTEGER         reduce using rule 32 (value -> inline_table .)
    STRING          reduce using rule 32 (value -> inline_table .)
    LITERAL_STRING  reduce using rule 32 (value -> inline_table .)
    $end            reduce using rule 32 (value -> inline_table .)
    COMMA           reduce using rule 32 (value -> inline_table .)
    RBRACE          reduce using rule 32 (value -> inline_table .)
    RBRACKET        reduce using rule 32 (value -> inline_table .)


state 38

    (33) array -> LBRACKET . value_list RBRACKET
    (34) value_list -> . value
    (35) value_list -> . value COMMA value_list
    (17) value -> . STRING
    (18) value -> . LITERAL_STRING
    (19) value -> . INTEGER
    (20) value -> . FLOAT
    (21) value -> . HEX_INTEGER
    (22) value -> . OCT_INTEGER
    (23) value -> . BIN_INTEGER
    (24) value -> . BOOLEAN
    (25) value -> . OFFSET_DATE_TIME
    (26) value -> . LOCAL_DATE_TIME
    (27) value -> . LOCAL_DATE
    (28) value -> . LOCAL_TIME
    (29) value -> . MULTILINE_STRING
    (30) value -> . LITERAL_MULTILINE_STRING
    (31) value -> . array
    (32) value -> . inline_table
    (33) array -> . LBRACKET value_list RBRACKET
    (36) inline_table -> . LBRACE key_val_list RBRACE

    STRING          shift and go to state 22
    LITERAL_STRING  shift and go to state 23
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    HEX_INTEGER     shift and go to state 26
    OCT_INTEGER     shift and go to state 27
    BIN_INTEGER     shift and go to state 28
    BOOLEAN         shift and go to state 29
    OFFSET_DATE_TIME shift and go to state 30
    LOCAL_DATE_TIME shift and go to state 31
    LOCAL_DATE      shift and go to state 32
    LOCAL_TIME      shift and go to state 33
    MULTILINE_STRING shift and go to state 34
    LITERAL_MULTILINE_STRING shift and go to state 35
    LBRACKET        shift and go to state 38
    LBRACE          shift and go to state 39

    value_list                     shift and go to state 42
    value                          shift and go to state 43
    array                          shift and go to state 36
    inline_table                   shift and go to state 37

state 39

    (36) inline_table -> LBRACE . key_val_list RBRACE
    (37) key_val_list -> . key_val
    (38) key_val_list -> . key_val COMMA key_val_list
    (6) key_val -> . key EQUALS value
    (7) key -> . simple_key
    (8) key -> . dotted_key
    (9) simple_key -> . bare_key
    (10) simple_key -> . quoted_key
    (15) dotted_key -> . simple_key DOT simple_key
    (16) dotted_key -> . FLOAT
    (11) bare_key -> . IDENTIFIER
    (12) bare_key -> . INTEGER
    (13) quoted_key -> . STRING
    (14) quoted_key -> . LITERAL_STRING

    FLOAT           shift and go to state 12
    IDENTIFIER      shift and go to state 13
    INTEGER         shift and go to state 14
    STRING          shift and go to state 15
    LITERAL_STRING  shift and go to state 16

    key_val_list                   shift and go to state 44
    key_val                        shift and go to state 45
    key                            shift and go to state 6
    simple_key                     shift and go to state 8
    dotted_key                     shift and go to state 9
    bare_key                       shift and go to state 10
    quoted_key                     shift and go to state 11

state 40

    (39) table -> LBRACKET key RBRACKET .

    LBRACKET        reduce using rule 39 (table -> LBRACKET key RBRACKET .)
    FLOAT           reduce using rule 39 (table -> LBRACKET key RBRACKET .)
    IDENTIFIER      reduce using rule 39 (table -> LBRACKET key RBRACKET .)
    INTEGER         reduce using rule 39 (table -> LBRACKET key RBRACKET .)
    STRING          reduce using rule 39 (table -> LBRACKET key RBRACKET .)
    LITERAL_STRING  reduce using rule 39 (table -> LBRACKET key RBRACKET .)
    $end            reduce using rule 39 (table -> LBRACKET key RBRACKET .)


state 41

    (15) dotted_key -> simple_key DOT simple_key .

    EQUALS          reduce using rule 15 (dotted_key -> simple_key DOT simple_key .)
    RBRACKET        reduce using rule 15 (dotted_key -> simple_key DOT simple_key .)


state 42

    (33) array -> LBRACKET value_list . RBRACKET

    RBRACKET        shift and go to state 46


state 43

    (34) value_list -> value .
    (35) value_list -> value . COMMA value_list

    RBRACKET        reduce using rule 34 (value_list -> value .)
    COMMA           shift and go to state 47


state 44

    (36) inline_table -> LBRACE key_val_list . RBRACE

    RBRACE          shift and go to state 48


state 45

    (37) key_val_list -> key_val .
    (38) key_val_list -> key_val . COMMA key_val_list

    RBRACE          reduce using rule 37 (key_val_list -> key_val .)
    COMMA           shift and go to state 49


state 46

    (33) array -> LBRACKET value_list RBRACKET .

    LBRACKET        reduce using rule 33 (array -> LBRACKET value_list RBRACKET .)
    FLOAT           reduce using rule 33 (array -> LBRACKET value_list RBRACKET .)
    IDENTIFIER      reduce using rule 33 (array -> LBRACKET value_list RBRACKET .)
    INTEGER         reduce using rule 33 (array -> LBRACKET value_list RBRACKET .)
    STRING          reduce using rule 33 (array -> LBRACKET value_list RBRACKET .)
    LITERAL_STRING  reduce using rule 33 (array -> LBRACKET value_list RBRACKET .)
    $end            reduce using rule 33 (array -> LBRACKET value_list RBRACKET .)
    COMMA           reduce using rule 33 (array -> LBRACKET value_list RBRACKET .)
    RBRACE          reduce using rule 33 (array -> LBRACKET value_list RBRACKET .)
    RBRACKET        reduce using rule 33 (array -> LBRACKET value_list RBRACKET .)


state 47

    (35) value_list -> value COMMA . value_list
    (34) value_list -> . value
    (35) value_list -> . value COMMA value_list
    (17) value -> . STRING
    (18) value -> . LITERAL_STRING
    (19) value -> . INTEGER
    (20) value -> . FLOAT
    (21) value -> . HEX_INTEGER
    (22) value -> . OCT_INTEGER
    (23) value -> . BIN_INTEGER
    (24) value -> . BOOLEAN
    (25) value -> . OFFSET_DATE_TIME
    (26) value -> . LOCAL_DATE_TIME
    (27) value -> . LOCAL_DATE
    (28) value -> . LOCAL_TIME
    (29) value -> . MULTILINE_STRING
    (30) value -> . LITERAL_MULTILINE_STRING
    (31) value -> . array
    (32) value -> . inline_table
    (33) array -> . LBRACKET value_list RBRACKET
    (36) inline_table -> . LBRACE key_val_list RBRACE

    STRING          shift and go to state 22
    LITERAL_STRING  shift and go to state 23
    INTEGER         shift and go to state 24
    FLOAT           shift and go to state 25
    HEX_INTEGER     shift and go to state 26
    OCT_INTEGER     shift and go to state 27
    BIN_INTEGER     shift and go to state 28
    BOOLEAN         shift and go to state 29
    OFFSET_DATE_TIME shift and go to state 30
    LOCAL_DATE_TIME shift and go to state 31
    LOCAL_DATE      shift and go to state 32
    LOCAL_TIME      shift and go to state 33
    MULTILINE_STRING shift and go to state 34
    LITERAL_MULTILINE_STRING shift and go to state 35
    LBRACKET        shift and go to state 38
    LBRACE          shift and go to state 39

    value                          shift and go to state 43
    value_list                     shift and go to state 50
    array                          shift and go to state 36
    inline_table                   shift and go to state 37

state 48

    (36) inline_table -> LBRACE key_val_list RBRACE .

    LBRACKET        reduce using rule 36 (inline_table -> LBRACE key_val_list RBRACE .)
    FLOAT           reduce using rule 36 (inline_table -> LBRACE key_val_list RBRACE .)
    IDENTIFIER      reduce using rule 36 (inline_table -> LBRACE key_val_list RBRACE .)
    INTEGER         reduce using rule 36 (inline_table -> LBRACE key_val_list RBRACE .)
    STRING          reduce using rule 36 (inline_table -> LBRACE key_val_list RBRACE .)
    LITERAL_STRING  reduce using rule 36 (inline_table -> LBRACE key_val_list RBRACE .)
    $end            reduce using rule 36 (inline_table -> LBRACE key_val_list RBRACE .)
    COMMA           reduce using rule 36 (inline_table -> LBRACE key_val_list RBRACE .)
    RBRACE          reduce using rule 36 (inline_table -> LBRACE key_val_list RBRACE .)
    RBRACKET        reduce using rule 36 (inline_table -> LBRACE key_val_list RBRACE .)


state 49

    (38) key_val_list -> key_val COMMA . key_val_list
    (37) key_val_list -> . key_val
    (38) key_val_list -> . key_val COMMA key_val_list
    (6) key_val -> . key EQUALS value
    (7) key -> . simple_key
    (8) key -> . dotted_key
    (9) simple_key -> . bare_key
    (10) simple_key -> . quoted_key
    (15) dotted_key -> . simple_key DOT simple_key
    (16) dotted_key -> . FLOAT
    (11) bare_key -> . IDENTIFIER
    (12) bare_key -> . INTEGER
    (13) quoted_key -> . STRING
    (14) quoted_key -> . LITERAL_STRING

    FLOAT           shift and go to state 12
    IDENTIFIER      shift and go to state 13
    INTEGER         shift and go to state 14
    STRING          shift and go to state 15
    LITERAL_STRING  shift and go to state 16

    key_val                        shift and go to state 45
    key_val_list                   shift and go to state 51
    key                            shift and go to state 6
    simple_key                     shift and go to state 8
    dotted_key                     shift and go to state 9
    bare_key                       shift and go to state 10
    quoted_key                     shift and go to state 11

state 50

    (35) value_list -> value COMMA value_list .

    RBRACKET        reduce using rule 35 (value_list -> value COMMA value_list .)


state 51

    (38) key_val_list -> key_val COMMA key_val_list .

    RBRACE          reduce using rule 38 (key_val_list -> key_val COMMA key_val_list .)

